"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCustomFunctionsMetadata = void 0;
const parseTree_1 = require("./parseTree");
const fs_1 = require("fs");
/* global console */
/**
 * Generate the metadata of the custom functions
 * @param inputFile - File that contains the custom functions
 * @param outputFileName - Name of the file to create (i.e functions.json)
 */
function generateCustomFunctionsMetadata(input, wantConsoleOutput = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const inputFiles = Array.isArray(input) ? input : [input];
        const functions = [];
        const enums = [];
        const generateResults = {
            metadataJson: "",
            associate: [],
            errors: [],
        };
        if (input && inputFiles.length > 0) {
            inputFiles.forEach((inputFile) => {
                inputFile = inputFile.trim();
                if (!inputFile) {
                    // ignore empty strings
                }
                else if (!(0, fs_1.existsSync)(inputFile)) {
                    throw new Error(`File not found: ${inputFile}`);
                }
                else {
                    const sourceCode = (0, fs_1.readFileSync)(inputFile, "utf-8");
                    const parseTreeResult = (0, parseTree_1.parseTree)(sourceCode, inputFile);
                    parseTreeResult.extras.forEach((extra) => extra.errors.forEach((err) => generateResults.errors.push(err)));
                    if (generateResults.errors.length > 0) {
                        if (wantConsoleOutput) {
                            console.error("Errors in file: " + inputFile);
                            generateResults.errors.forEach((err) => console.error(err));
                        }
                    }
                    else {
                        functions.push(...parseTreeResult.functions);
                        generateResults.associate.push(...parseTreeResult.associate);
                        enums.push(...parseTreeResult.enums);
                    }
                }
            });
            if (functions.length > 0) {
                const metadata = {
                    allowCustomDataForDataTypeAny: true,
                    functions: functions,
                    enums: enums,
                };
                if (enums.length == 0) {
                    delete metadata.enums;
                }
                generateResults.metadataJson = JSON.stringify(metadata, null, 4);
            }
        }
        return generateResults;
    });
}
exports.generateCustomFunctionsMetadata = generateCustomFunctionsMetadata;
//# sourceMappingURL=generate.js.map