"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logError = exports.parseTree = void 0;
const typescript_1 = __importDefault(require("typescript"));
const XRegExp = require("xregexp");
// JSDoc tags
const CANCELABLE = "cancelable";
const CAPTURESCALLINGOBJECT = "capturescallingobject";
const CUSTOM_ENUM = "customenum"; // case insensitive @CustomEnum tag to identify custom enums in JSDoc
const CUSTOM_FUNCTION = "customfunction"; // case insensitive @CustomFunction tag to identify custom functions in JSDoc
const EXCLUDEFROMAUTOCOMPLETE = "excludefromautocomplete";
const HELPURL_PARAM = "helpurl";
const LINKEDENTITYLOADSERVICE = "linkedentityloadservice";
const REQUIRESADDRESS = "requiresaddress";
const REQUIRESPARAMETERADDRESSES = "requiresparameteraddresses";
const STREAMING = "streaming";
const VOLATILE = "volatile";
const TYPE_MAPPINGS = {
    [typescript_1.default.SyntaxKind.NumberKeyword]: "number",
    [typescript_1.default.SyntaxKind.StringKeyword]: "string",
    [typescript_1.default.SyntaxKind.BooleanKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.AnyKeyword]: "any",
    [typescript_1.default.SyntaxKind.UnionType]: "any",
    [typescript_1.default.SyntaxKind.TupleType]: "any",
    [typescript_1.default.SyntaxKind.EnumKeyword]: "any",
    [typescript_1.default.SyntaxKind.ObjectKeyword]: "any",
    [typescript_1.default.SyntaxKind.VoidKeyword]: "any",
    [typescript_1.default.SyntaxKind.UnknownKeyword]: "any",
};
const TYPE_CUSTOM_FUNCTIONS_STREAMING = {
    ["customfunctions.streaminghandler"]: 1,
    ["customfunctions.streaminginvocation"]: 2,
};
const TYPE_CUSTOM_FUNCTION_CANCELABLE = {
    ["customfunctions.cancelablehandler"]: 1,
    ["customfunctions.cancelableinvocation"]: 2,
};
const TYPE_CUSTOM_FUNCTION_INVOCATION = "customfunctions.invocation";
// These does not work if the developer is using namespace/type alias. To support that, we'd need to
// use typeChecker.getFullyQualifiedName, which in turns requires creating a program out of the source file
// (which we don't do now) and passing the type checker all the way down to getParamType. This would be a
// larger refactor (e.g., rewriting parseTree into a class) and is tracked as a work item.
const CELLVALUETYPE_MAPPINGS = {
    "Excel.CellValue": "cellvalue",
    "Excel.BooleanCellValue": "booleancellvalue",
    "Excel.DoubleCellValue": "doublecellvalue",
    "Excel.EntityCellValue": "entitycellvalue",
    "Excel.ErrorCellValue": "errorcellvalue",
    "Excel.FormattedNumberCellValue": "formattednumbercellvalue",
    "Excel.LinkedEntityCellValue": "linkedentitycellvalue",
    "Excel.LocalImageCellValue": "localimagecellvalue",
    "Excel.StringCellValue": "stringcellvalue",
    "Excel.WebImageCellValue": "webimagecellvalue",
    "Excel.ArrayCellValue": "unsupported",
    "Excel.EmptyCellValue": "unsupported",
    "Excel.ReferenceCellValue": "unsupported",
    "Excel.ValueTypeNotAvailableCellValue": "unsupported",
};
const CELLVALUETYPE_TO_BASICTYPE_MAPPINGS = {
    cellvalue: "any",
    booleancellvalue: "boolean",
    doublecellvalue: "number",
    entitycellvalue: "any",
    errorcellvalue: "any",
    formattednumbercellvalue: "number",
    linkedentitycellvalue: "any",
    localimagecellvalue: "any",
    stringcellvalue: "string",
    webimagecellvalue: "any",
};
/**
 * Takes the sourceCode and attempts to parse the functions information
 * @param sourceCode source containing the custom functions
 * @param sourceFileName source code file name or path
 * @param parseTreeOptions options to enable or disable
 */
function parseTree(sourceCode, sourceFileName) {
    const associate = [];
    const functions = [];
    const extras = [];
    const basicEnums = [];
    const customEnums = [];
    const functionNames = [];
    const metadataFunctionNames = [];
    const metadataFunctionIds = [];
    const metadataEnumIds = [];
    const sourceFile = typescript_1.default.createSourceFile(sourceFileName, sourceCode, typescript_1.default.ScriptTarget.Latest, true);
    buildEnums(sourceFile);
    buildCustomEnums(sourceFile);
    buildFunctions(sourceFile);
    const parseTreeResult = {
        associate,
        extras,
        functions,
        enums: customEnums,
    };
    return parseTreeResult;
    // Build list for basic enums without tag "@customenum"
    function buildEnums(node) {
        if (typescript_1.default.isEnumDeclaration(node) && !isCustomEnum(node)) {
            basicEnums.push(node.name.getText());
        }
        typescript_1.default.forEachChild(node, buildEnums);
    }
    // Build list for custom enums tagged with "@customenum"
    function buildCustomEnums(node) {
        if (typescript_1.default.isEnumDeclaration(node)) {
            buildSingleCustomEnum(node);
        }
        typescript_1.default.forEachChild(node, buildCustomEnums);
    }
    function buildSingleCustomEnum(node) {
        var _a;
        if (!typescript_1.default.isEnumDeclaration(node) ||
            !node.parent ||
            node.parent.kind !== typescript_1.default.SyntaxKind.SourceFile) {
            return;
        }
        const enumDeclaration = node;
        if (!isCustomEnum(enumDeclaration) || enumDeclaration.members.length === 0) {
            return;
        }
        const extra = {
            errors: [],
            javascriptFunctionName: "",
        };
        const id = enumDeclaration.name.text;
        validateName(id, getPosition(enumDeclaration), extra, "enum"); // Call `validateName` instead of `validateId` because the enum name acts as the id
        extras.push(extra);
        if (checkForDuplicate(metadataEnumIds, id)) {
            const errorString = `@${CUSTOM_ENUM} tag specifies a duplicate name: ${id}`;
            extras.push({
                errors: [logError(errorString, getPosition(enumDeclaration))],
                javascriptFunctionName: "",
            });
        }
        metadataEnumIds.push(id);
        let isNumberEnum = true; // Default true for enums without initializer
        // Extract JSDoc type from the enum declaration
        let jsDocType = null;
        const comment = getTagComment(enumDeclaration, CUSTOM_ENUM);
        if (comment) {
            const typeMatch = comment === null || comment === void 0 ? void 0 : comment.match(/\{\s*(string|number)\s*\}/);
            if (!typeMatch) {
                const errorString = `Unknown enum type defined after @${CUSTOM_ENUM} tag. Please use "{string}" or "{number}": ${id}`;
                extras.push({
                    errors: [logError(errorString, getPosition(enumDeclaration))],
                    javascriptFunctionName: "",
                });
            }
            jsDocType = typeMatch ? typeMatch[1].trim() : null;
        }
        // Get the first member of the enum to determine if it is a number or string enum
        const firstMember = enumDeclaration.members[0];
        if (firstMember.initializer) {
            const initializerText = firstMember.initializer.getText();
            isNumberEnum = !isNaN(Number(initializerText));
            if (jsDocType) {
                // Check if the enum type matches the type in the JSDoc annotation
                const errorString = `Enum type must match the enum type in annotation: ${id}`;
                if ((isNumberEnum && jsDocType !== "number") || (!isNumberEnum && jsDocType !== "string")) {
                    extras.push({
                        errors: [logError(errorString, getPosition(enumDeclaration))],
                        javascriptFunctionName: "",
                    });
                    return;
                }
            }
        }
        const values = [];
        let defaultValueForNumberEnum = 0;
        for (const member of enumDeclaration.members) {
            const value = member.initializer
                ? JSON.parse(member.initializer.getText())
                : defaultValueForNumberEnum++;
            if ((isNumberEnum && typeof value !== "number") ||
                (!isNumberEnum && typeof value !== "string")) {
                const errorString = `Enum value type must be consistent: ${id}`;
                extras.push({
                    errors: [logError(errorString, getPosition(enumDeclaration))],
                    javascriptFunctionName: "",
                });
                return;
            }
            const name = member.name.getText();
            const tooltip = ((_a = typescript_1.default
                .getLeadingCommentRanges(sourceFile.getFullText(), member.getFullStart())) === null || _a === void 0 ? void 0 : _a.map((range) => sourceFile.getFullText().substring(range.pos, range.end).trim()).join("\n").replace(/^\s*[/*]+\s?/gm, "").replace(/\s*[/*]+$/gm, "")) || ""; // Strip trailing slashes, asterisks, and whitespace
            values.push({ name: name, value: value, tooltip: tooltip });
        }
        const enumItem = {
            id,
            type: isNumberEnum ? "number" : "string",
            values,
        };
        customEnums.push(enumItem);
    }
    function buildFunctions(node) {
        if (typescript_1.default.isFunctionDeclaration(node)) {
            if (node.parent && node.parent.kind === typescript_1.default.SyntaxKind.SourceFile) {
                const functionDeclaration = node;
                const position = getPosition(functionDeclaration);
                const functionErrors = [];
                const functionName = functionDeclaration.name ? functionDeclaration.name.text : "";
                if (checkForDuplicate(functionNames, functionName)) {
                    const errorString = `Duplicate function name: ${functionName}`;
                    functionErrors.push(logError(errorString, position));
                }
                functionNames.push(functionName);
                if (isCustomFunction(functionDeclaration)) {
                    const extra = {
                        errors: functionErrors,
                        javascriptFunctionName: functionName,
                    };
                    const idName = getTagComment(functionDeclaration, CUSTOM_FUNCTION);
                    const idNameArray = idName.split(" ");
                    const jsDocParamInfo = getJSDocParams(functionDeclaration);
                    const jsDocParamTypeInfo = getJSDocParamsType(functionDeclaration);
                    const jsDocParamOptionalInfo = getJSDocParamsOptionalType(functionDeclaration);
                    const [lastParameter] = functionDeclaration.parameters.slice(-1);
                    const isStreamingFunction = hasStreamingInvocationParameter(lastParameter, jsDocParamTypeInfo);
                    const isCancelableFunction = hasCancelableInvocationParameter(lastParameter, jsDocParamTypeInfo);
                    const isInvocationFunction = hasInvocationParameter(lastParameter, jsDocParamTypeInfo);
                    const parametersToParse = isStreamingFunction || isCancelableFunction || isInvocationFunction
                        ? functionDeclaration.parameters.slice(0, functionDeclaration.parameters.length - 1)
                        : functionDeclaration.parameters.slice(0, functionDeclaration.parameters.length);
                    const parameterItems = {
                        basicEnums: basicEnums,
                        customEnums: customEnums,
                        extra,
                        jsDocParamInfo,
                        jsDocParamOptionalInfo,
                        jsDocParamTypeInfo,
                        parametersToParse,
                    };
                    const parameters = getParameters(parameterItems);
                    const description = getDescription(functionDeclaration);
                    const helpUrl = normalizeLineEndings(getTagComment(functionDeclaration, HELPURL_PARAM));
                    const result = getResults(functionDeclaration, isStreamingFunction, lastParameter, jsDocParamTypeInfo, extra, basicEnums, customEnums);
                    const options = getOptions(functionDeclaration, isStreamingFunction, isCancelableFunction, isInvocationFunction, extra);
                    const funcName = functionDeclaration.name ? functionDeclaration.name.text : "";
                    const id = normalizeCustomFunctionId(idNameArray[0] || funcName);
                    const name = idNameArray[1] || id;
                    validateId(id, position, extra);
                    validateName(name, position, extra, "function");
                    if (checkForDuplicate(metadataFunctionNames, name)) {
                        const errorString = `@customfunction tag specifies a duplicate name: ${name}`;
                        functionErrors.push(logError(errorString, position));
                    }
                    metadataFunctionNames.push(name);
                    if (checkForDuplicate(metadataFunctionIds, id)) {
                        const errorString = `@customfunction tag specifies a duplicate id: ${id}`;
                        functionErrors.push(logError(errorString, position));
                    }
                    metadataFunctionIds.push(id);
                    associate.push({ sourceFileName, functionName, id });
                    const functionMetadata = {
                        description,
                        helpUrl,
                        id,
                        name,
                        options,
                        parameters,
                        result,
                    };
                    if (!options.cancelable &&
                        !options.requiresAddress &&
                        !options.requiresStreamAddress &&
                        !options.stream &&
                        !options.volatile &&
                        !options.requiresParameterAddresses &&
                        !options.requiresStreamParameterAddresses &&
                        !options.excludeFromAutoComplete &&
                        !options.linkedEntityLoadService &&
                        !options.capturesCallingObject) {
                        delete functionMetadata.options;
                    }
                    else {
                        if (!options.cancelable) {
                            delete options.cancelable;
                        }
                        if (!options.requiresAddress) {
                            delete options.requiresAddress;
                        }
                        if (!options.requiresStreamAddress) {
                            delete options.requiresStreamAddress;
                        }
                        if (!options.stream) {
                            delete options.stream;
                        }
                        if (!options.volatile) {
                            delete options.volatile;
                        }
                        if (!options.requiresParameterAddresses) {
                            delete options.requiresParameterAddresses;
                        }
                        if (!options.requiresStreamParameterAddresses) {
                            delete options.requiresStreamParameterAddresses;
                        }
                        if (!options.excludeFromAutoComplete) {
                            delete options.excludeFromAutoComplete;
                        }
                        if (!options.linkedEntityLoadService) {
                            delete options.linkedEntityLoadService;
                        }
                        if (!options.capturesCallingObject) {
                            delete options.capturesCallingObject;
                        }
                    }
                    if (!functionMetadata.helpUrl) {
                        delete functionMetadata.helpUrl;
                    }
                    if (!functionMetadata.description) {
                        delete functionMetadata.description;
                    }
                    if (!functionMetadata.result) {
                        delete functionMetadata.result;
                    }
                    extras.push(extra);
                    functions.push(functionMetadata);
                }
            }
        }
        typescript_1.default.forEachChild(node, buildFunctions);
    }
}
exports.parseTree = parseTree;
/**
 * Case insensitive check of item in list
 * @param list Array of strings
 * @param item String to check against the list
 */
function checkForDuplicate(list, item) {
    let duplicate = false;
    list.forEach((value) => {
        if (areStringsEqual(value, item)) {
            duplicate = true;
        }
    });
    return duplicate;
}
/**
 * Function to compare strings
 * @param first First string
 * @param second Second string
 * @param ignoreCase Ignore the case of the string
 */
function areStringsEqual(first, second, ignoreCase = true) {
    return typeof first === "string" && typeof second === "string"
        ? first.localeCompare(second, undefined, ignoreCase ? { sensitivity: "accent" } : undefined) ===
            0
        : first === second;
}
/**
 * Get the position of the object
 * @param node function, parameter, or node
 */
function getPosition(node, position) {
    let positionLocation = null;
    if (node) {
        const pos = position ? position : node.pos;
        positionLocation = node.getSourceFile().getLineAndCharacterOfPosition(pos);
    }
    return positionLocation;
}
/**
 * Verifies if the id is valid and logs error if not.
 * @param id Id of the function
 */
function validateId(id, position, extra) {
    const idRegExString = "^[a-zA-Z0-9._]*$";
    const idRegEx = new RegExp(idRegExString);
    if (!idRegEx.test(id)) {
        if (!id) {
            id = "Function name is invalid";
        }
        const errorString = `The custom function id contains invalid characters. Allowed characters are ('A-Z','a-z','0-9','.','_'):${id}`;
        extra.errors.push(logError(errorString, position));
    }
    if (id.length > 128) {
        const errorString = `The custom function id exceeds the maximum of 128 characters allowed.`;
        extra.errors.push(logError(errorString, position));
    }
}
/**
 * Verifies if the name is valid and logs error if not.
 * @param name Name of the function or enum
 * @param position Position of the function or enum
 * @param extra Extra information, especially errors
 * @param type Type of the object, either "function" or "enum"
 */
function validateName(name, position, extra, type = "function") {
    const startsWithLetterRegEx = XRegExp("^[\\pL]");
    const validNameRegEx = XRegExp("^[\\pL][\\pL0-9._]*$");
    let errorString;
    if (!name) {
        errorString = `You need to provide a custom ${type} name.`;
        extra.errors.push(logError(errorString, position));
    }
    if (!startsWithLetterRegEx.test(name)) {
        errorString = `The custom ${type} name "${name}" should start with an alphabetic character.`;
        extra.errors.push(logError(errorString, position));
    }
    else if (!validNameRegEx.test(name)) {
        errorString = `The custom ${type} name "${name}" should contain only alphabetic characters, numbers (0-9), period (.), and underscore (_).`;
        extra.errors.push(logError(errorString, position));
    }
    if (name.length > 128) {
        errorString = `The custom ${type} name "${name}" is too long. It must be 128 characters or less.`;
        extra.errors.push(logError(errorString, position));
    }
}
/**
 * Normalize the id of the custom function
 * @param id Parameter id of the custom function
 */
function normalizeCustomFunctionId(id) {
    return id ? id.toLocaleUpperCase() : id;
}
/**
 * Determines the options parameters for the json
 * @param func - Function
 * @param isStreamingFunction - Is is a steaming function
 */
function getOptions(func, isStreamingFunction, isCancelableFunction, isInvocationFunction, extra) {
    const optionsItem = {
        cancelable: isCancelableTag(func, isCancelableFunction),
        requiresAddress: isAddressRequired(func) && !isStreaming(func, isStreamingFunction),
        requiresStreamAddress: isAddressRequired(func) && isStreaming(func, isStreamingFunction),
        stream: isStreaming(func, isStreamingFunction),
        volatile: isVolatile(func),
        requiresParameterAddresses: isRequiresParameterAddresses(func) && !isStreaming(func, isStreamingFunction),
        requiresStreamParameterAddresses: isRequiresParameterAddresses(func) && isStreaming(func, isStreamingFunction),
        excludeFromAutoComplete: isExcludedFromAutoComplete(func),
        linkedEntityLoadService: isLinkedEntityLoadService(func),
        capturesCallingObject: capturesCallingObject(func),
    };
    if (isAddressRequired(func) || isRequiresParameterAddresses(func)) {
        let errorParam = isAddressRequired(func)
            ? "@requiresAddress"
            : "@requiresParameterAddresses";
        if (!isStreamingFunction && !isCancelableFunction && !isInvocationFunction) {
            const functionPosition = getPosition(func, func.parameters.end);
            const errorString = `Since ${errorParam} is present, the last function parameter should be of type CustomFunctions.Invocation :`;
            extra.errors.push(logError(errorString, functionPosition));
        }
    }
    if (optionsItem.linkedEntityLoadService &&
        (optionsItem.excludeFromAutoComplete ||
            optionsItem.volatile ||
            optionsItem.stream ||
            optionsItem.requiresAddress ||
            optionsItem.requiresParameterAddresses ||
            optionsItem.capturesCallingObject)) {
        let errorParam = "";
        const functionPosition = getPosition(func);
        if (optionsItem.excludeFromAutoComplete) {
            errorParam = "@excludeFromAutoComplete";
        }
        else if (optionsItem.volatile) {
            errorParam = "@volatile";
        }
        else if (optionsItem.stream) {
            errorParam = "@streaming";
        }
        else if (optionsItem.requiresAddress) {
            errorParam = "@requiresAddress";
        }
        else if (optionsItem.requiresParameterAddresses) {
            errorParam = "@requiresParameterAddresses";
        }
        else if (optionsItem.capturesCallingObject) {
            errorParam = "@capturesCallingObject";
        }
        const errorString = `${errorParam} cannot be used with @linkedEntityLoadService.`;
        extra.errors.push(logError(errorString, functionPosition));
    }
    return optionsItem;
}
/**
 * Determines the results parameter for the json
 * @param func - Function
 * @param isStreaming - Is a streaming function
 * @param lastParameter - Last parameter of the function signature
 */
function getResults(func, isStreamingFunction, lastParameter, jsDocParamTypeInfo, extra, basicEnums, customEnums) {
    let resultType = "any";
    let resultDim = "scalar";
    const defaultResultItem = {
        dimensionality: resultDim,
        type: resultType,
    };
    const lastParameterPosition = getPosition(lastParameter);
    // Try and determine the return type.  If one can't be determined we will set to any type
    if (isStreamingFunction) {
        const lastParameterType = lastParameter.type;
        if (!lastParameterType) {
            // Need to get result type from param {type}
            const name = lastParameter.name.text;
            const ptype = jsDocParamTypeInfo[name];
            // @ts-ignore
            resultType = ptype.returnType;
            resultDim = ptype.dimensionality;
            const paramResultItem = {
                dimensionality: resultDim,
                type: resultType,
            };
            if (paramResultItem.dimensionality === "scalar") {
                delete paramResultItem.dimensionality;
            }
            return paramResultItem;
        }
        if (!lastParameterType.typeArguments || lastParameterType.typeArguments.length !== 1) {
            const errorString = "The 'CustomFunctions.StreamingHandler' needs to be passed in a single result type (e.g., 'CustomFunctions.StreamingHandler < number >') :";
            extra.errors.push(logError(errorString, lastParameterPosition));
            return defaultResultItem;
        }
        const returnType = func.type;
        if (returnType && returnType.getFullText().trim() !== "void") {
            const errorString = `A streaming function should return 'void'. Use CustomFunctions.StreamingHandler.setResult() to set results.`;
            extra.errors.push(logError(errorString, lastParameterPosition));
            return defaultResultItem;
        }
        resultType = getParamType(lastParameterType.typeArguments[0], extra, basicEnums, customEnums).type;
        resultDim = getParamDim(lastParameterType.typeArguments[0]);
    }
    else if (func.type) {
        if (func.type.kind === typescript_1.default.SyntaxKind.TypeReference &&
            func.type.typeName.getText() === "Promise" &&
            func.type.typeArguments &&
            // @ts-ignore
            func.type.typeArguments.length === 1) {
            resultType = getParamType(
            // @ts-ignore
            func.type.typeArguments[0], extra, basicEnums, customEnums).type;
            resultDim = getParamDim(
            // @ts-ignore
            func.type.typeArguments[0]);
        }
        else {
            resultType = getParamType(func.type, extra, basicEnums, customEnums).type;
            resultDim = getParamDim(func.type);
        }
    }
    // Check the code comments for @return parameter
    const returnTypeFromJSDoc = typescript_1.default.getJSDocReturnType(func);
    if (returnTypeFromJSDoc) {
        if (func.type && func.type.kind !== returnTypeFromJSDoc.kind) {
            const name = func.name.text;
            const returnPosition = getPosition(returnTypeFromJSDoc);
            const errorString = `Type {${typescript_1.default.SyntaxKind[func.type.kind]}:${typescript_1.default.SyntaxKind[returnTypeFromJSDoc.kind]}} doesn't match for return type : ${name}`;
            extra.errors.push(logError(errorString, returnPosition));
        }
        if (returnTypeFromJSDoc.kind === typescript_1.default.SyntaxKind.TypeReference &&
            returnTypeFromJSDoc.typeName.getText() === "Promise" &&
            returnTypeFromJSDoc.typeArguments &&
            // @ts-ignore
            returnTypeFromJSDoc.typeArguments.length === 1) {
            resultType = getParamType(
            // @ts-ignore
            returnTypeFromJSDoc.typeArguments[0], extra, basicEnums, customEnums).type;
            resultDim = getParamDim(
            // @ts-ignore
            returnTypeFromJSDoc.typeArguments[0]);
        }
        else {
            resultType = getParamType(returnTypeFromJSDoc, extra, basicEnums, customEnums).type;
            resultDim = getParamDim(returnTypeFromJSDoc);
        }
    }
    const resultItem = {
        dimensionality: resultDim,
        type: resultType,
    };
    // We convert cell value types to "any".
    if (Object.values(CELLVALUETYPE_MAPPINGS).includes(resultType)) {
        resultType = "any";
    }
    // Only return dimensionality = matrix.  Default assumed scalar
    if (resultDim === "scalar") {
        delete resultItem.dimensionality;
    }
    if (resultType === "any") {
        delete resultItem.type;
    }
    return resultItem;
}
/**
 * Determines the parameter details for the json
 * @param params - Parameters
 * @param jsDocParamTypeInfo - jsDocs parameter type info
 * @param jsDocParamInfo = jsDocs parameter info
 */
function getParameters(parameterItem) {
    const parameterMetadata = [];
    parameterItem.parametersToParse
        .map((p) => {
        const parameterPosition = getPosition(p);
        // Get type node of parameter from typescript
        let typeNode = p.type;
        const name = p.name.text;
        // Get type node of parameter from jsDocs
        const parameterJSDocTypeNode = typescript_1.default.getJSDocType(p);
        if (parameterJSDocTypeNode && typeNode) {
            if (parameterJSDocTypeNode.kind !== typeNode.kind) {
                const errorString = `Type {${typescript_1.default.SyntaxKind[parameterJSDocTypeNode.kind]}:${typescript_1.default.SyntaxKind[typeNode.kind]}} doesn't match for parameter : ${name}`;
                parameterItem.extra.errors.push(logError(errorString, parameterPosition));
            }
        }
        if (!typeNode && parameterJSDocTypeNode) {
            typeNode = parameterJSDocTypeNode;
        }
        const ptype = getParamType(typeNode, parameterItem.extra, parameterItem.basicEnums, parameterItem.customEnums);
        const pMetadataItem = Object.assign({ description: parameterItem.jsDocParamInfo[name], dimensionality: getParamDim(typeNode), name, optional: getParamOptional(p, parameterItem.jsDocParamOptionalInfo), repeating: isRepeatingParameter(typeNode) }, ptype);
        // Only return dimensionality = matrix.  Default assumed scalar
        if (pMetadataItem.dimensionality === "scalar") {
            delete pMetadataItem.dimensionality;
        }
        // only include optional if true
        if (!pMetadataItem.optional) {
            delete pMetadataItem.optional;
        }
        // only include description if it has a value
        if (!pMetadataItem.description) {
            delete pMetadataItem.description;
        }
        // only return repeating if true and allowed
        if (!pMetadataItem.repeating) {
            delete pMetadataItem.repeating;
        }
        parameterMetadata.push(pMetadataItem);
    })
        .filter((meta) => meta);
    return parameterMetadata;
}
/**
 * Used to set repeating parameter true for 1d and 3d arrays
 * @param type Node to check
 * @param jsDocParamType Type from jsDoc
 */
function isRepeatingParameter(type) {
    let repeating = false;
    // Set repeating true for 1D and 3D array types
    if (type) {
        if (typescript_1.default.isTypeReferenceNode(type) || typescript_1.default.isArrayTypeNode(type)) {
            const array = getArrayDimensionalityAndType(type);
            if (array.dimensionality === 1 || array.dimensionality === 3) {
                repeating = true;
            }
        }
    }
    return repeating;
}
function normalizeLineEndings(text) {
    return text ? text.replace(/\r\n|\r/g, "\n") : text;
}
/**
 * Determines the description parameter for the json
 * @param node - jsDoc node
 */
function getDescription(node) {
    let description = "";
    // @ts-ignore
    if (node.jsDoc[0]) {
        // @ts-ignore
        description = node.jsDoc[0].comment;
    }
    return normalizeLineEndings(description);
}
/**
 * Find the tag with the specified name.
 * @param node - jsDocs node
 * @returns the tag if found; undefined otherwise.
 */
function findTag(node, tagName) {
    return typescript_1.default.getJSDocTags(node).find((tag) => containsTag(tag, tagName));
}
/**
 * If a node contains the named tag, returns the tag comment, otherwise returns "".
 */
function getTagComment(node, tagName) {
    var _a;
    const tag = findTag(node, tagName);
    return ((_a = tag === null || tag === void 0 ? void 0 : tag.comment) === null || _a === void 0 ? void 0 : _a.toString()) || "";
}
/**
 * Determine if a node contains a tag.
 * @param node - jsDocs node
 * @returns true if the node contains the tag; false otherwise.
 */
function hasTag(node, tagName) {
    return findTag(node, tagName) !== undefined;
}
/**
 * Returns true if function is a custom function
 * @param node - jsDocs node
 */
function isCustomFunction(node) {
    return hasTag(node, CUSTOM_FUNCTION);
}
/**
 * Returns true if node is a custom enum
 * @param node - jsDocs node
 */
function isCustomEnum(node) {
    return hasTag(node, CUSTOM_ENUM);
}
/**
 * Returns true if volatile tag found in comments
 * @param node jsDocs node
 */
function isVolatile(node) {
    return hasTag(node, VOLATILE);
}
/**
 * Returns true if requiresAddress tag found in comments
 * @param node jsDocs node
 */
function isAddressRequired(node) {
    return hasTag(node, REQUIRESADDRESS);
}
/**
 * Returns true if RequiresParameterAddresses tag found in comments
 * @param node jsDocs node
 */
function isRequiresParameterAddresses(node) {
    return hasTag(node, REQUIRESPARAMETERADDRESSES);
}
/**
 * Returns true if excludedFromAutoComplete tag found in comments
 * @param node jsDocs node
 */
function isExcludedFromAutoComplete(node) {
    return hasTag(node, EXCLUDEFROMAUTOCOMPLETE);
}
/**
 * Returns true if linkedEntityLoadService tag found in comments
 * @param node jsDocs node
 */
function isLinkedEntityLoadService(node) {
    return hasTag(node, LINKEDENTITYLOADSERVICE);
}
/**
 * Returns true if capturesCallingObject tag found in comments
 * @param node jsDocs node
 */
function capturesCallingObject(node) {
    return hasTag(node, CAPTURESCALLINGOBJECT);
}
function containsTag(tag, tagName) {
    return tag.tagName.escapedText.toLowerCase() === tagName;
}
/**
 * Returns true if function is streaming
 * @param node - jsDocs node
 * @param streamFunction - Is streaming function already determined by signature
 */
function isStreaming(node, streamFunction) {
    // If streaming already determined by function signature then return true
    return streamFunction || hasTag(node, STREAMING);
}
/**
 * Returns true if streaming function is cancelable
 * @param node - jsDocs node
 */
function isCancelableTag(node, cancelableFunction) {
    return cancelableFunction || hasTag(node, CANCELABLE);
}
/**
 * This method will parse out all of the @param tags of a JSDoc and return a dictionary
 * @param node - The function to parse the JSDoc params from
 */
function getJSDocParams(node) {
    const jsDocParamInfo = {};
    typescript_1.default.getAllJSDocTagsOfKind(node, typescript_1.default.SyntaxKind.JSDocParameterTag).forEach((tag) => {
        if (tag.comment) {
            const tagComment = tag.comment.toString();
            const comment = (tagComment.startsWith("-") ? tagComment.slice(1) : tagComment).trim();
            // @ts-ignore
            jsDocParamInfo[tag.name.getFullText()] = comment;
        }
        else {
            // Description is missing so add empty string
            // @ts-ignore
            jsDocParamInfo[tag.name.getFullText()] = "";
        }
    });
    return jsDocParamInfo;
}
/**
 * This method will parse out all of the @param tags of a JSDoc and return a dictionary
 * @param node - The function to parse the JSDoc params from
 */
function getJSDocParamsType(node) {
    const jsDocParamTypeInfo = {};
    typescript_1.default.getAllJSDocTagsOfKind(node, typescript_1.default.SyntaxKind.JSDocParameterTag).forEach(
    // @ts-ignore
    (tag) => {
        if (tag.typeExpression) {
            // Should be in the form {string}, so removing the {} around type
            const paramType = tag.typeExpression
                .getFullText()
                .slice(1, tag.typeExpression.getFullText().length - 1);
            const openBracket = paramType.indexOf("<");
            let insertValue;
            // Check for generic type
            if (openBracket > -1) {
                let subType = paramType.slice(openBracket + 1, paramType.length - 1);
                const dimCount = (subType.match(/\[/g) || []).length;
                if (dimCount > 0) {
                    insertValue = {
                        type: paramType.slice(0, openBracket),
                        returnType: subType.slice(0, subType.indexOf("[")),
                        dimensionality: dimCount == 1 ? "scalar" : "matrix",
                    };
                }
                else {
                    insertValue = { type: paramType.slice(0, openBracket), returnType: subType };
                }
            }
            else {
                insertValue = { type: paramType };
            }
            // @ts-ignore
            jsDocParamTypeInfo[tag.name.getFullText()] = insertValue;
        }
        else {
            // Set as any
            // @ts-ignore
            jsDocParamTypeInfo[tag.name.getFullText()] = { type: "any" };
        }
    });
    return jsDocParamTypeInfo;
}
/**
 * This method will parse out all of the @param tags of a JSDoc and return a dictionary
 * @param node - The function to parse the JSDoc params from
 */
function getJSDocParamsOptionalType(node) {
    const jsDocParamOptionalTypeInfo = {};
    typescript_1.default.getAllJSDocTagsOfKind(node, typescript_1.default.SyntaxKind.JSDocParameterTag).forEach(
    // @ts-ignore
    (tag) => {
        // @ts-ignore
        jsDocParamOptionalTypeInfo[tag.name.getFullText()] =
            tag.isBracketed;
    });
    return jsDocParamOptionalTypeInfo;
}
/**
 * Determines if the last parameter is streaming
 * @param param ParameterDeclaration
 */
function hasStreamingInvocationParameter(param, jsDocParamTypeInfo) {
    const isTypeReferenceNode = param && param.type && typescript_1.default.isTypeReferenceNode(param.type);
    if (param) {
        const name = param.name.text;
        if (name && jsDocParamTypeInfo[name]) {
            const ptype = jsDocParamTypeInfo[name].type;
            // Check to see if the streaming parameter is defined in the comment section
            if (ptype) {
                const typecheck = 
                // @ts-ignore
                TYPE_CUSTOM_FUNCTIONS_STREAMING[ptype.toLocaleLowerCase()];
                if (typecheck) {
                    return true;
                }
            }
        }
    }
    if (!isTypeReferenceNode) {
        return false;
    }
    const typeRef = param.type;
    const typeName = typeRef.typeName.getText();
    return (typeName === "CustomFunctions.StreamingInvocation" ||
        typeName === "CustomFunctions.StreamingHandler" ||
        typeName === "IStreamingCustomFunctionHandler" /* older version*/);
}
/**
 * Determines if the last parameter is of type cancelable
 * @param param ParameterDeclaration
 * @param jsDocParamTypeInfo
 */
function hasCancelableInvocationParameter(param, jsDocParamTypeInfo) {
    const isTypeReferenceNode = param && param.type && typescript_1.default.isTypeReferenceNode(param.type);
    if (param) {
        const name = param.name.text;
        if (name && jsDocParamTypeInfo[name]) {
            const ptype = jsDocParamTypeInfo[name].type;
            // Check to see if the cancelable parameter is defined in the comment section
            if (ptype) {
                const cancelableTypeCheck = 
                // @ts-ignore
                TYPE_CUSTOM_FUNCTION_CANCELABLE[ptype.toLocaleLowerCase()];
                if (cancelableTypeCheck) {
                    return true;
                }
            }
        }
    }
    if (!isTypeReferenceNode) {
        return false;
    }
    const typeRef = param.type;
    const typeName = typeRef.typeName.getText();
    return (typeName === "CustomFunctions.CancelableHandler" ||
        typeName === "CustomFunctions.CancelableInvocation");
}
/**
 * Determines if the last parameter is of type invocation
 * @param param ParameterDeclaration
 * @param jsDocParamTypeInfo
 */
function hasInvocationParameter(param, jsDocParamTypeInfo) {
    const isTypeReferenceNode = param && param.type && typescript_1.default.isTypeReferenceNode(param.type);
    if (param) {
        const name = param.name.text;
        if (name && jsDocParamTypeInfo[name]) {
            const ptype = jsDocParamTypeInfo[name].type;
            // Check to see if the invocation parameter is defined in the comment section
            if (ptype) {
                if (ptype.toLocaleLowerCase() === TYPE_CUSTOM_FUNCTION_INVOCATION) {
                    return true;
                }
            }
        }
    }
    if (!isTypeReferenceNode) {
        return false;
    }
    const typeRef = param.type;
    return typeRef.typeName.getText() === "CustomFunctions.Invocation";
}
/**
 * Gets the parameter type of the node
 * @param node TypeNode
 */
function getParamType(node, extra, basicEnums, customEnums) {
    let type = "any";
    // Only get type for typescript files. js files will return "any" for all types
    if (!node) {
        return { type: type };
    }
    const typePosition = getPosition(node);
    // Get the inner type node if it is an array
    if (typeNodeIsArray(node)) {
        let arrayType = {
            dimensionality: 0,
            node,
        };
        arrayType = getArrayDimensionalityAndType(node);
        node = arrayType.node;
    }
    // We currently accept the following types of reference node: enum will be converted to "any",
    // Excel.CellValue will be converted accordingly. Anything else is invalid. (Array reference node has already been covered above.)
    if (typescript_1.default.isTypeReferenceNode(node)) {
        const typeReferenceNode = node;
        let nodeTypeName = typeReferenceNode.typeName.getText();
        if (basicEnums.indexOf(nodeTypeName) >= 0) {
            // Type found in the basicEnumList
            return { type: type };
        }
        for (const enumItem of customEnums) {
            if (enumItem.id === nodeTypeName) {
                // Type found in the customEnumList
                return { type: enumItem.type, customEnumType: nodeTypeName };
            }
        }
        // @ts-ignore
        if (CELLVALUETYPE_MAPPINGS[nodeTypeName]) {
            // @ts-ignore
            let cellValue = CELLVALUETYPE_MAPPINGS[nodeTypeName];
            if (cellValue === "unsupported") {
                const errorString = `Custom function does not support cell value type: ${typeReferenceNode.typeName.getText()}`;
                extra.errors.push(logError(errorString, typePosition));
                return { type: type };
            }
            // @ts-ignore
            return { type: CELLVALUETYPE_TO_BASICTYPE_MAPPINGS[cellValue], cellValueType: cellValue };
        }
        const errorString = `Custom function does not support type "${typeReferenceNode.typeName.getText()}" as input or return parameter.`;
        extra.errors.push(logError(errorString, typePosition));
        return { type: type };
    }
    // @ts-ignore
    type = TYPE_MAPPINGS[node.kind];
    if (!type) {
        extra.errors.push(logError("Type doesn't match mappings", typePosition));
    }
    return { type: type };
}
/**
 * Helper function that checks whether a TypeNode is an array.
 * There are two cases: Array<sometype> or sometype[].
 * @param node TypeNode
 */
function typeNodeIsArray(node) {
    // [] case
    if (typescript_1.default.isArrayTypeNode(node)) {
        return true;
    }
    // Array<sometype> case
    if (typescript_1.default.isTypeReferenceNode(node)) {
        return node.typeName.getText() === "Array";
    }
    return false;
}
/**
 * Wrapper function which will return the dimensionality and type of the array
 * @param node TypeNode
 */
function getArrayDimensionalityAndType(node) {
    let array = {
        dimensionality: 0,
        node,
    };
    if (typescript_1.default.isArrayTypeNode(node)) {
        array = getArrayDimensionalityAndTypeForArrayTypeNode(node);
    }
    else if (typescript_1.default.isTypeReferenceNode(node)) {
        array = getArrayDimensionalityAndTypeForReferenceNode(node);
    }
    return array;
}
/**
 * Returns the dimensionality and type of array for TypeNode (sometype[] or higher dimension)
 * @param node TypeNode
 */
function getArrayDimensionalityAndTypeForArrayTypeNode(node) {
    const array = {
        dimensionality: 1,
        node,
    };
    let nodeCheck = node.elementType;
    array.node = nodeCheck;
    while (typescript_1.default.isArrayTypeNode(nodeCheck)) {
        ++array.dimensionality;
        nodeCheck = nodeCheck.elementType;
        array.node = nodeCheck;
    }
    return array;
}
/**
 * Returns the dimensionality and type of array for ReferenceNode (Array<sometype> or higher dimension)
 * @param node TypeReferenceNode
 */
function getArrayDimensionalityAndTypeForReferenceNode(node) {
    const array = {
        dimensionality: 0,
        node,
    };
    let nodeCheck = node;
    let dimensionalityCount = 0;
    while (typescript_1.default.isTypeReferenceNode(nodeCheck) &&
        nodeCheck.typeName.getText() === "Array" &&
        nodeCheck.typeArguments &&
        nodeCheck.typeArguments.length === 1) {
        nodeCheck = nodeCheck.typeArguments[0];
        ++dimensionalityCount;
    }
    array.dimensionality = dimensionalityCount;
    array.node = nodeCheck;
    return array;
}
/**
 * Get the parameter dimensionality of the node
 * @param t TypeNode
 */
function getParamDim(t) {
    let dimensionality = "scalar";
    if (t) {
        if (typescript_1.default.isTypeReferenceNode(t) || typescript_1.default.isArrayTypeNode(t)) {
            const array = getArrayDimensionalityAndType(t);
            if (array.dimensionality > 1) {
                dimensionality = "matrix";
            }
        }
    }
    return dimensionality;
}
function getParamOptional(p, jsDocParamOptionalInfo) {
    let optional = false;
    const name = p.name.text;
    const isOptional = p.questionToken != null || p.initializer != null || p.dotDotDotToken != null;
    // If parameter is found to be optional in ts
    if (isOptional) {
        optional = true;
        // Else check the comments section for [name] format
    }
    else {
        // @ts-ignore
        optional = jsDocParamOptionalInfo[name];
    }
    return optional;
}
/**
 * Log containing all the errors found while parsing
 * @param error Error string to add to the log
 */
function logError(error, position) {
    if (position) {
        error = `${error} (${position.line + 1},${position.character + 1})`;
    }
    return error;
}
exports.logError = logError;
//# sourceMappingURL=parseTree.js.map